//Задача:
    //Вы участвуете в рыцарском поединке по стрельбе из лука. Поединок начинается с того,
    //что оба соперника располагаются на расстоянии двадцати шагов друг от друга, и каждому
    //дается только одна стрела и, соответственно, только один шанс на выстрел. В течение
    //поединка соперники ходят по очереди, каждый ход участник может либо сделать шаг
    //вперед, либо произвести выстрел. Чем ближе находятся соперники друг к другу, тем
    //выше шанс попадания. При этом шанс попадания увеличивается линейно, начиная с
    //определенного значения в начале поединка до 100% при полном сближении.
    //Сложность состоит в том, что если вы сделаете выстрел и промахнетесь, соперник будет
    //иметь право сделать необходимое количество шагов, подойти к вам вплотную, и
    //выстрелить с гарантированным попаданием, что обеспечит ему победу.
    //Создайте алгоритм, который, отталкиваясь от заданных значений шансов попадания для
    //вас и соперника в начале поединка, будет определять номер шага когда вам нужно
    //произвести выстрел для получения наиболее высоких шансов на победу.
//Входящие параметры:
    //Значения шансов попадания в начале поединка (разные для вас и соперника, и оба в
    //диапазоне от 0.1 до 0.3), а также номер участника, который ходит первым.
//Выходные данные:
    //Наиболее оптимальный шаг для произведения выстрела (в диапазоне от 1 до 10).

class Player { // Класс для создания игроков 
    constructor(playerName, startMove, startChance) {
        this.playerName = playerName; 
        this.startChance = startChance; 
        this.startMove = startMove; 
        this.currentStep = 0; 
        this.chanceForOneStep = (1 - startChance) / 20;
    }
    //Вспомогатьельные методы для измениения параметров игроков
    //===========================================================
    makeStep() { // Увеличивает текущее кол-во шагов 
        this.currentStep++;
    };
    changeStartMove() { // Изменяет очередность хода
        this.startMove = (this.startMove) ? false : true;
    };
    increaseTheChance() { // Увеличивает шанс на попадпние
        this.startChance += this.chanceForOneStep;
    };
    ResultStep() { // Выводит текущий шаг игрока
        return this.currentStep;
    };
    //============================================================
    
    //Методы для использования в игре
    //============================================================
    makeMovePlayer() { // Увеличивает показатели при своем шаге
        this.makeStep();
        this.increaseTheChance();
        this.changeStartMove();
    };
    makeMoveOpponent() { // Увеличивает показатели если ходит соперник
        this.increaseTheChance();
        this.changeStartMove();
    };
    //============================================================
};


class Game { // Класс для создания игры
    constructor(whoIsFirst, startChanceForFirtPlayer, startChanceForSecondPlayer) {
        // Конструкция создания игроков
        //============================================================
        this.player1 = new Player('Player1', (whoIsFirst == 1) ? true : false, startChanceForFirtPlayer);
        this.player2 = new Player('Player2', (whoIsFirst == 2) ? true : false, startChanceForSecondPlayer);
        //=============================================================
    };

    getWinStep() { // Метод вычисляет являеться ли текущий шаг подходящим
        let chanceToLose = 1 - this.player1.startChance;
        let chanceToLoseIfSteep = this.player2.startChance + this.player2.chanceForOneStep;
        return (chanceToLose < chanceToLoseIfSteep && this.player1.startChance > 0.51) ? true : false;
    };

    startGame() {  // Метод запуска игры
        let steps = 20; // Кол-во шагов для двух игроков
        while (steps > 0) { // Выход из цикла
            if (this.player1.startMove) {  
                if (this.getWinStep()) { 
                    return `Шанс на поражнеие при выстреле: ${(1 - this.player1.startChance).toFixed(3)};
 Шанс на поражение в случае совершения хода: ${(this.player2.startChance +  this.player2.chanceForOneStep).toFixed(3)};
 Исходя из этих показателей необходимо сделать высрел на ${this.player1.ResultStep()} шаге.`
                } 
                steps -= 1; 
                this.player1.makeMovePlayer();
                this.player2.makeMoveOpponent();
            } else if (this.player2.startMove) { 
                steps -= 1;
                this.player2.makeMovePlayer(); 
                this.player1.makeMoveOpponent(); 
            }
        }
    }
};


//Примеры использования:
    //let firstGame = new Game(1, 0.2, 0.3);
    //firstGame.startGame(); =>  'Шанс на поражнеие при выстреле: 0.480
                               // Шанс на поражение в случае совершения хода: 0.615
                               // Исходя из этих показателей необходимо сделать высрел на 4 шаге.'
    
    //let firstGame = new Game(2, 0.1, 0.3);
    //firstGame.startGame(); => 'Шанс на поражнеие при выстреле: 0.405
                              // Шанс на поражение в случае совершения хода: 0.720 
                              // Исходя из этих показателей необходимо сделать высрел на 5 шаге.'


//Алгоритм:
    //1. Создаем новую игру через класс и принимаем данные 
        // (Кто первый ходит, шанс на попадание первого игрока и шанс на попадание второго игрока)
    //2. Создаем через конструктор двух игроков исходя из полученых данных
    //3. Запускаем метод startGame() для игры где производиться расчет с помошью цикла
    //4. Когда игрок имеет больше шансов проиграть при совершении хода, чем при совершении встрела шаг считаеться оптимальным
    //5. Завершаем цикл и выводим лог с указанием номера шага на котором нужно сделать выстрел.
