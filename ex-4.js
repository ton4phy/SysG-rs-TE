//Задача:
    //Вы работаете с компанией по доставке товаров, которая ежедневно пользуется платной
    //автомобильной дорогой. Плата за путешествие взимается на 10-и пунктах оплаты
    //расположенных вдоль дороги. Водителям компании необходимо преодолеть весь путь,
    //оплатив комиссию за проезд на каждом из пунктов.
    //Сложность состоит в том, что по правилам, комиссию можно оплачивать только одной
    //единственной монетой. В случае, если ее номинал выше, чем стоимость проезда,
    //водитель сдачу не получает и остаток сгорает. Если же монета, наоборот, не полностью
    //покрывает стоимость проезда, то вашей компании насчитывается долг. При этом
    //стоимость проезда на каждом из пунктов абсолютно произвольно изменяется в конце дня,
    //и может варьироваться в диапазоне от 1-ой до 10-и копеек включительно. Также
    //известно, что несколько пунктов оплаты могут выставлять одну и ту же стоимость
    //проезда, а общая сумма проезда через все пункты будет всегда больше 55-и копеек.
    //Каждому водителю в начале пути выдается 10 монет, по одной монете каждого
    //достоинства (т.е. одна монета достоинством в копейку, одна монета достоинством в две
    //копейки, одна - три, и так далее, до десяти копеек включительно). Используя генетический
    //алгоритм, вам необходимо найти такую стратегию оплат путешествия, при которой долг
    //водителя в конце пути будет минимальным. Алгоритм будет применяться компанией в
    //начале каждого дня, и использовать данные по новым, только что установленным,
    //размерам комиссий на пунктах оплат для получения новой стратегии для водителей.
//Входящие параметры:
    //Массив из десяти произвольных чисел от 1 до 10, представляющих собой размеры
    //комиссий на каждом из пунктов. Числа в массиве могут повторятся, и их сумма будет
    //всегда больше чем 55.
//Выходные данные:
    //Массив из десяти чисел, представляющих собой достоинства монет, расположенные в
    //порядке, оптимальном для оплат на каждом из пунктов (так чтобы долг компании после
    //всех оплат был минимальным).

class Driver { // Класс для создания водителя
    constructor(array) { // Получение массива из коммисий проездов
        this.coin = array.slice();
        this.coinList = array.slice();
    }
    // Вспомогательные методы для расчета 
    //=======================================
    getMaxCoin(arr) { // Выводит самый высокий елемент массива
        return Math.max.apply(null, arr);
    }

    findIndex(array, value) { // Находит значение в массиве и возвращает его индекс
        for (var i = 0; i < array.length; i++)
            if (array[i] == value) return i;
    }
    //=========================================
    
    // Метод для создание массива с нужным расположением монет
    //=======================================================================
    getCoinList() {
        if(this.coin.length != 10) return "Incorrect Value!"; // Проверка на кореектность данных
        for (let i = 10; i > 0; i--) { // Конструкция сортировки монет 
            let index = this.findIndex(this.coin, this.getMaxCoin(this.coin));
            this.coin.splice(index, 1, 0);
            this.coinList.splice(index, 1, i);
        }
        return this.coinList;
    };
    //========================================================================
}



//Примеры использования:
    // let arr1 = [3, 5, 1, 5, 10, 10, 6, 9, 9, 8];
    // let firstDriver = new Driver(arr1);
        // firstDriver.getCoinList(); // => [ 2, 4, 1, 3, 10, 9, 5, 8, 7, 6 ]
    
    // let arr2 = [5, 9, 10, 2, 5, 10, 8, 2, 1, 6];
    // let secondDriver = new Driver(arr2);
        // secondDriver.getCoinList(); // => [ 5, 8, 10, 3, 4, 9, 7, 2, 1, 6 ]

// Алгоритм:
//    1. Получение массива данных
//    2. Копирование массива для работы с ним
//    3. С помошью метода getCoinList(), запускаеться сортировка 
//        1.1 Циклом присваиваються индексы от 10 до 1 на место самого большого в массиве числа
//        1.2 Замена самого большого элемента на 0
//    4. Возврат нового массива